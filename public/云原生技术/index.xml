<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>云原生技术s on 千兆光年</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/</link>
        <description>Recent content in 云原生技术s on 千兆光年</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 08 Nov 2021 18:32:39 +0800</lastBuildDate><atom:link href="http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>K8s Network</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-network/</link>
        <pubDate>Mon, 08 Nov 2021 18:32:39 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-network/</guid>
        <description>&lt;h3 id=&#34;network-namespace&#34;&gt;network namespace
&lt;/h3&gt;&lt;p&gt;Linux network namespace 是虚拟化网络的基石，所以我们首先介绍他。于Linux内核2.6版本引入，主要是隔离linux系统的设备，以及ip地址，端口，路由表，防火墙规则等网络资源。&lt;/p&gt;
&lt;p&gt;通过命令我们可以设置网卡到新创建的名称空间中，然后可以互相ping通，但是路由表和防火墙规则还是隔离的&lt;/p&gt;
&lt;p&gt;注意，创建的虚拟设备最多只能存在一个名称空间中&lt;/p&gt;
&lt;p&gt;namespace存在的奥秘/proc/PID/ns&lt;/p&gt;
&lt;p&gt;每个进程都有属于自己的/proc/pid/ns&lt;/p&gt;
&lt;p&gt;进来看下，其实可以看到很多符号连接，其中一个作用就是某两个进程是否属于一个namespace&lt;/p&gt;
&lt;p&gt;还有一个作用就是 文件描述符处于open状态，namespace就一直存在，也就是说不需要有进程也会存在&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;touch /tmp/net
mount --bind /proc/$$/ns/net /tmp/net
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上所示，只要挂载起来就能保持一致存在，知道net被卸载&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;namespace添加进程 setns 系统调用&lt;/li&gt;
&lt;li&gt;脱离namespace unshare系统调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;veth-pair&#34;&gt;veth pair
&lt;/h3&gt;&lt;p&gt;虚拟以太网卡，设备总是以成对方式出现，类似管道。&lt;/p&gt;
&lt;p&gt;容器和虚拟以太网卡的关系，容器内的eth0和宿主机上一个veth是成对的关系&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cat /sys/class/net/eth0/iflink

# 查找宿主机网卡
#!/bin/bash
echo -e &amp;#34;----statrt-------&amp;#34;
cd /sys/class/net/
for i in `ls |grep veth`;do
  index=$(cat $i/ifindex)
  if [[ ${index} == ${1} ]];then
       echo -e &amp;#34;${i}\n&amp;#34;
       echo -e &amp;#34;${index}&amp;#34;
  fi
done
echo -e &amp;#34;----------end--------&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bridge&#34;&gt;bridge
&lt;/h3&gt;&lt;p&gt;用于连接网卡设备，网桥是一个虚拟的二层设备，根据MAC地址转发到对应的端口。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ip link add name br0 type bridge
ip link set br0 up
# brctl  创建
brctl addbr br0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设物理网卡是1.2.3.4， 网关是1.2.3.1&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建一对设备
ip link add veth0 type veth peer name veth1
ip addr add 1.2.3.101/24 dev veth0
ip addr add 1.2.3.102/24 dev veth1
ip link set veth0 up
ip link set veth1 up
# 设置到br0上
ip link set dev veth0 master br0
# 查看网桥有什么设备
bridge link
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上操作后，veth0和协议栈的连接就变成了单向通道，此时协议栈可以发送数据给veth0，但是veth0不能发送到协议栈，这就相当于，br0做了一层拦截，所以我们把ip应该配置给br0&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ip addr del 1.2.3.101/24 dev veth0
ip addr add 1.2.3.101/24 dev br0
## 物理网卡连接到br0
ip link set dev eth0 master br0
## 此时eth0间、相当于一条网线了，所以去除ip
ip addr del 192.168.  dev eth0
## 设置默认路由
ip route add default via 192.168.3.1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vxlan&#34;&gt;vxlan
&lt;/h3&gt;&lt;p&gt;隧道网络代表是vxlan，一种overlay技术，是基于三层网络构建二层网络。不同于一对一的隧道协议，vxlan是一个一对多的网络，一个vxlan设备可以像网桥一样自动学习其他对端ip地址，也支持静态转发表。&lt;/p&gt;
&lt;p&gt;vxlan重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VTEH设备，网络边缘设备，用来进行vxlan的封包和解包工作&lt;/li&gt;
&lt;li&gt;VNI vxlan网络标识&lt;/li&gt;
&lt;li&gt;tunnel 隧道一个逻辑概念，一个虚拟隧道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kubernetes网络&#34;&gt;kubernetes网络
&lt;/h3&gt;&lt;p&gt;在kubernetes网络模型中，每台node节点有自己独立的网段呢，容器直接按照目标容器ip地址进行访问。所以重点解决如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各宿主机容器ip段不能重复，需要ip段分配机制&lt;/li&gt;
&lt;li&gt;pod发出的流量到达所在服务器时，服务器网络层应当根据目标ip转发到目标服务器的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以重点就在，ip地址分配和路由&lt;/p&gt;
&lt;h3 id=&#34;cni&#34;&gt;CNI
&lt;/h3&gt;&lt;p&gt;是kubernetes与低层网络的一个抽象层，为k8s屏蔽了底层网络实现的复杂度，通识届欧了k8s具体网络插件的实现。&lt;/p&gt;
&lt;p&gt;CNI主要有两类接口&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Addnetwork(net *networkconfig, rt *runtimeconf) (result, error)
DelNetwork(net *networkconfig, rt *runtimeconf)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;kubelet和cni给出了两个默认的文件系统路径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/etc/cni/net.d/ 配置文件&lt;/li&gt;
&lt;li&gt;/opt/cni/bin/&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;主机内组网模型&#34;&gt;主机内组网模型
&lt;/h4&gt;&lt;p&gt;veth pair + bridge将容器与主机的网络协议栈连接起来，从而使数据包可以进出pod。容器放在主机根network namespace 中连接到网桥，可以使用pod内之间互相通讯。&lt;/p&gt;
&lt;h4 id=&#34;跨节点组网模型&#34;&gt;跨节点组网模型
&lt;/h4&gt;</description>
        </item>
        <item>
        <title>K8s Cni</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-cni/</link>
        <pubDate>Thu, 17 Sep 2020 15:00:30 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-cni/</guid>
        <description>&lt;p&gt;Kubernetets社区对网络实现方案开放了CNI标准，在我们部署K8S的时候，其中有一个步骤是安装CNI包，这里就是会把CNI插件所需要的基础组建的二进制文件给安装到&lt;code&gt;/opt/cni/bin&lt;/code&gt;，包含如下组建：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# pwd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/opt/cni/bin
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ll -h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.9M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; bridge
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 7.3M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; dhcp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.1M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; flannel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.2M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; host-device
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.2M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; host-local
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.6M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; ipvlan
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.2M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; loopback
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.6M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; macvlan
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.5M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; portmap
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.9M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; ptp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 1.9M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; sample
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.1M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; tuning
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; root root 2.5M Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2019&lt;/span&gt; vlan
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上边插件类型基本会分为三种类型&lt;/p&gt;
&lt;h5 id=&#34;第一类main插件用来创建具体的网络设备的二进制文件&#34;&gt;第一类，main插件，用来创建具体的网络设备的二进制文件
&lt;/h5&gt;&lt;p&gt;如： bridge（网桥设备），ipvlan，loopback（回环设备），ptp（veth pair设备），vlan&lt;/p&gt;
&lt;h5 id=&#34;第二类ipam设备地址管理设备负责分配ip地址的二进制文件&#34;&gt;第二类，IPAM设备，地址管理设备，负责分配IP地址的二进制文件
&lt;/h5&gt;&lt;p&gt;如：dhcp，动态分配IP，host-local预先分配的ip&lt;/p&gt;
&lt;h5 id=&#34;第三类cni社区维护的内置cni插件&#34;&gt;第三类，CNI社区维护的内置CNI插件
&lt;/h5&gt;&lt;p&gt;如：flannel，专门为flannel项目提供的CNI插件；tuning，通过sysctl调整网络参数的设备；portmap，通过iptables配置端口设备的文件&lt;/p&gt;
&lt;p&gt;上边列出了安装默认带的基本插件，像calico这种，需要先下载后，放到这个目录就可以。要实现网络解决方案，除了上边的CNI网络插件，还要有方案本身的实现。&lt;/p&gt;
&lt;h5 id=&#34;网络解决方案&#34;&gt;网络解决方案
&lt;/h5&gt;&lt;p&gt;这一部分主要是实现配置隧道设备，配置宿主机路由，配置宿主机ARP和FDB表信息等工作。如flanneld进程&lt;/p&gt;
&lt;p&gt;接下来就是安装flanneld本身的安装，可以使用Damonset安装，也可以使用二进制文件直接安装，安装完成后并且启动后，会在每台宿主机上生成一个配置文件，如下面所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /etc/cni/net.d/10-flannel.conflist&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cbr0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;plugins&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;flannel&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;delegate&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hairpinMode&amp;#34;&lt;/span&gt;: true,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;isDefaultGateway&amp;#34;&lt;/span&gt;: true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;portmap&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;capabilities&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;portMappings&amp;#34;&lt;/span&gt;: true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;这个文件是给容器运行时读取的&lt;/strong&gt;，可以看到插件里面有两个，容器运行时会按照顺序加载。理论上这个目录只存在一个配置文件，如果存在多个，会按照配置文件的首字母首先加载第一个配置文件。&lt;/p&gt;
&lt;h4 id=&#34;cni插件工作原理&#34;&gt;CNI插件工作原理
&lt;/h4&gt;&lt;p&gt;当kubelet watch到pod被调度到本机后，就会开始进行创建pod的操作，他第一个创建的容器肯定是infra容器，这里创建容器是容器运行时，也就是dockershim组建，接着kubelet会执行setuppod方法，这个方法就是准备CNI参数，调用CNI插件准备网络。&lt;/p&gt;
&lt;p&gt;参数分为两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;dockershim的CNI环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;dockershim从CNI配置文件加载到的配置信息&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变量部分最重要的CNI_COMMAND,有add方法和del分别对应添加和删除&lt;/p&gt;
&lt;p&gt;配置信息是dockershim需要传入CNI的部分，以json格式传输，这部分被称之为网络配置信息，传给CNI插件后，插件会修改信息，补充信息，然后调用bridge，会传入上边的两部分信息，接下来briage插件会真正的开始创建虚拟设备，分别插入网桥和容器的一端&lt;/p&gt;
&lt;p&gt;接下来bridge插件调用ipam插件，为设备分配ip地址，同时设置默认路由。&lt;/p&gt;
&lt;p&gt;接下来为cni0网桥设置ip地址，操作完成后，cni插件会把容器地址返回给dockershim，然后被kubelet添加到pod status，这些流程基本就是二层叠加类型的创建过程了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/cni%E8%B0%83%E7%94%A8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;cni&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Prometheus本地存储</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/prometheus-local-storage/</link>
        <pubDate>Fri, 04 Sep 2020 16:10:02 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/prometheus-local-storage/</guid>
        <description>&lt;p&gt;Prometheus（普罗米修斯）存储经历了三个重要版本的变更v1&amp;gt;v2&amp;gt;v3，下面简述下各自版本的缺点。&lt;/p&gt;
&lt;h3 id=&#34;v1&#34;&gt;v1
&lt;/h3&gt;&lt;p&gt;2012年发布，整个数据被分为数据和原数据两部分，然后被保存在LevelDB中，并且每隔15分钟刷新一次，这样会有一个严重的问题，如果主机当机，会最长丢失15分钟的数据。v1版本有性能问题，每秒只能支持50000个样本的写入。10s周期，1000个指标，大约只能支撑500台机器的指标收集。&lt;/p&gt;
&lt;h3 id=&#34;v2&#34;&gt;v2
&lt;/h3&gt;&lt;p&gt;针对v1的问题，2015年发布了V2版本，这时候，每个时序数据用单个的文件保存，性能提高至800000样本。但是每个时序都对应一个文件，产生了严重的时序流失和写放大问题，内存使用率不断增加，经常发生OOM，同事大量文件的创建，造成了内核文件句柄过多的错误。&lt;/p&gt;
&lt;h3 id=&#34;v3&#34;&gt;v3
&lt;/h3&gt;&lt;p&gt;针对V2的问题，2017年发布了v3版本，解决了下面的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当机数据丢失的问题，引入WAL&lt;/li&gt;
&lt;li&gt;每秒1000 0000个样本接受&lt;/li&gt;
&lt;li&gt;CPU下降3倍，磁盘IO下降10倍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普罗米修斯的本地存储也被称之为Prometheus TSDB，TSDB的设计核心包含两个，WAL和block，block有包含chunk，meta.json，index，tombstones。&lt;/p&gt;
&lt;p&gt;最新的block被称之为head block，支持读写，其他block只读方式存储在硬盘中。&lt;/p&gt;
&lt;h5 id=&#34;block&#34;&gt;block
&lt;/h5&gt;&lt;p&gt;按照时间分割成block，大小不固定，按照设定的步数生成block，如：步数3，默认两小时，则第一次两小时生成一个，6小时生成一个，18小时生成一个，生成了三次。而且block会自动合并，如将3个2小时合并成一个6小时的，减少block的个数。每个block有全局唯一的uuid，这个是包含时间戳的，可以方便的排序。&lt;/p&gt;
&lt;p&gt;block内部包含如下的几部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chunks 压缩后的时序数据，每个大小512M&lt;/li&gt;
&lt;li&gt;index 索引，为快速查询提供的索引，&lt;/li&gt;
&lt;li&gt;tombstones，用于对数据进行软删除，如果一个block删除了部分数据，可用这个&lt;/li&gt;
&lt;li&gt;meta.json 记录了block的原数据信息，开始时间，截止时间，样本数等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/prometheus-tsdb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tsdb&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;wal&#34;&gt;WAL
&lt;/h5&gt;&lt;p&gt;为了防止为写入磁盘的数据丢失，引入了这个机制&lt;/p&gt;
&lt;h3 id=&#34;相关参数&#34;&gt;相关参数
&lt;/h3&gt;&lt;p&gt;数据保存的相关参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ndash;storage.tsdb.retention 存储时间，默认15天&lt;/li&gt;
&lt;li&gt;&amp;ndash;storage.tsdb.parh  存储路径&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Docker安装指定版本</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker-install/</link>
        <pubDate>Fri, 07 Aug 2020 15:54:02 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker-install/</guid>
        <description>&lt;p&gt;生产环境中，我们经常需要安装指定版本的docker，稳定性和安全性方面都能得到保证。下面的教程是生产在用的一套教程，各位可以参考。&lt;/p&gt;
&lt;h5 id=&#34;指定版本安装docker&#34;&gt;指定版本安装docker
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NEW_USER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;udocker
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adduser $NEW_USER
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$NEW_USER&lt;span style=&#34;color:#e6db74&#34;&gt; ALL=(ALL) ALL&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; /etc/sudoers
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export docker_version&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;18.06.3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum install -y yum-utils device-mapper-persistent-data  lvm2 bash-completion
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum-config-manager --add-repo  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;version&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;yum list docker-ce.x86_64 --showduplicates | sort -r|grep &lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;docker_version&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;|awk &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum -y install --setopt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;obsoletes&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; docker-ce-&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;version&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;usermod -aG docker $NEW_USER
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;systemctl enable docker
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;锁定docker版本&#34;&gt;锁定docker版本
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum install yum-plugin-versionlock
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum versionlock add docker-ce docker-ce-cli
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum versionlock list
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum versionlock delete &amp;lt;软件包名称&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum versionlock clear
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;删除docker&#34;&gt;删除docker
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum remove docker &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-client &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-client-latest &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-common &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-latest &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-latest-logrotate &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-logrotate &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-selinux &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-engine-selinux &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              docker-engine &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;              container*
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;修改docker参数&#34;&gt;修改docker参数
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;oom-score-adjust&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;-1000&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;log-driver&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;json-file&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;log-opts&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;max-size&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100m&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;max-file&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;data-root&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/home/docker&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;max-concurrent-downloads&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;max-concurrent-uploads&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;bip&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;169.254.30.1/28&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 最好自定义一个完全不会冲突的网断
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;insecure-registries&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;], &lt;span style=&#34;color:#75715e&#34;&gt;// 公司的镜像仓库
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;registry-mirrors&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;加速&amp;#34;&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;storage-driver&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;overlay2&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;storage-opts&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;overlay2.override_kernel_check=true&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;exec-opts&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;native.cgroupdriver=systemd&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对于通过systemd来管理服务的系统(比如CentOS&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;.X、Ubuntu&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;.X),&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;Docker有两处可以配置参数:&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;一个是docker.service服务配置文件,一个是Docker&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;daemon配置文件daemon.json&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;修改服务单元参数&#34;&gt;修改服务单元参数
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/usr/lib/systemd/system/docker.service
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;防止docker服务OOM： OOMScoreAdjust&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;-1000
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;开启iptables转发链：ExecStartPost&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/usr/sbin/iptables -P FORWARD ACCEPT 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;主机名配置
因为K8S的规定，主机名只支持包含 - 和 .(中横线和点)两种特殊符号，并且主机名不能出现重复
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;修改内核参数&#34;&gt;修改内核参数
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.bridge.bridge-nf-call-ip6tables&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.bridge.bridge-nf-call-iptables&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.ip_forward&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.all.forwarding&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.neigh.default.gc_thresh1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.neigh.default.gc_thresh2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6144&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.neigh.default.gc_thresh3&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.neigh.default.gc_interval&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.neigh.default.gc_stale_time&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;120&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 参考 https://github.com/prometheus/node_exporter#disabled-by-default&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.perf_event_paranoid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;-1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#sysctls for k8s node config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_slow_start_after_idle&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.core.rmem_max&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16777216&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.inotify.max_user_watches&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;524288&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.softlockup_all_cpu_backtrace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.softlockup_panic&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.watchdog_thresh&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.file-max&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2097152&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.inotify.max_user_instances&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.inotify.max_queued_events&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16384&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vm.max_map_count&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;262144&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.may_detach_mounts&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.core.netdev_max_backlog&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16384&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_wmem&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12582912&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16777216&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.core.wmem_max&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16777216&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.core.somaxconn&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32768&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.ip_forward&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_max_syn_backlog&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8096&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_rmem&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12582912&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16777216&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv6.conf.all.disable_ipv6&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv6.conf.default.disable_ipv6&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv6.conf.lo.disable_ipv6&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.yama.ptrace_scope&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vm.swappiness&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 可以控制core文件的文件名中是否添加pid作为扩展。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.core_uses_pid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Do not accept source routing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.default.accept_source_route&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.all.accept_source_route&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Promote secondary addresses when the primary address is removed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.default.promote_secondaries&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.all.promote_secondaries&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Enable hard and soft link protection&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.protected_hardlinks&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fs.protected_symlinks&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 源路由验证&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# see details in https://help.aliyun.com/knowledge_detail/39428.html&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.all.rp_filter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.default.rp_filter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.default.arp_announce &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.lo.arp_announce&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.conf.all.arp_announce&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# see details in https://help.aliyun.com/knowledge_detail/41334.html&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_max_tw_buckets&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_syncookies&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_fin_timeout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;net.ipv4.tcp_synack_retries&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kernel.sysrq&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Cgroups</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/cgroups/</link>
        <pubDate>Fri, 24 Jul 2020 09:55:57 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/cgroups/</guid>
        <description>&lt;p&gt;进程隔离后，本身会看不到其他的进程，此时会发生一个问题，独占资源，也就是说，我这个进程会把全部的资源全部跑满，其他的进程抢夺不到资源，这时候我们通常需要对隔离的进程进行一些资源的限制，这就是Linux 下的cgroups技术。&lt;/p&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介
&lt;/h3&gt;&lt;p&gt;cgroups是control groups的缩写，是内核提供的可以限制和隔离进程组所使用的资源的机制。&lt;/p&gt;
&lt;p&gt;基本概念介绍“&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务，task，通常是指一个系统进程&lt;/li&gt;
&lt;li&gt;控制组，是按照一个标准划分的一组进程，资源控制都是以控制组为单位的。一个进程可以加入到一个控制组，也可以从一个进程组迁移到另一个控制组。&lt;/li&gt;
&lt;li&gt;层级，控制组可以组织成层级的形式，就像是一颗树。控制族群树上的子节点继承父节点的属性&lt;/li&gt;
&lt;li&gt;子系统，一个子系统就是一个资源控制器，如cpu，mem等，代表着一种可以限制的资源。一个子系统附加到一个层级后，表示这个层级上的控制组全部受这个子系统控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理
&lt;/h3&gt;&lt;p&gt;cgroups的本质是给系统进程上挂上钩子（hooks），当task运行的时候触发钩子上所附带的子系统进行检测，最终按照设置进行资源限制和优先级分配。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/cgroups&lt;/code&gt;可以查看支持的子系统&lt;/p&gt;
&lt;p&gt;cgroups提供了虚拟文件系统作为用户接口，要是用系统，必须先进行挂载，默认挂载&lt;code&gt;/sys/fs/cgroups&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;规则&#34;&gt;规则
&lt;/h3&gt;&lt;p&gt;同一个层级结构可以挂载多个子系统&lt;/p&gt;
&lt;p&gt;一个子系统只能附加到一个层级结构上&lt;/p&gt;
&lt;p&gt;每次系统创建新层级时，该层级内的所有任务都是默认cgroups也就是root cgroups的初始成员，根层级时系统自动创建的&lt;/p&gt;
&lt;p&gt;一个任务可以时多个控制组的成员，但是cgroups必须是不同的层级&lt;/p&gt;
&lt;p&gt;父进程clone子进程时，子进程自动属于父进程所属的控制组，可以根据需要移出&lt;/p&gt;
&lt;h3 id=&#34;命令&#34;&gt;命令
&lt;/h3&gt;&lt;h4 id=&#34;lssubsys&#34;&gt;lssubsys
&lt;/h4&gt;&lt;p&gt;查看全部子系统&lt;/p&gt;
&lt;h4 id=&#34;lscgroup&#34;&gt;lscgroup
&lt;/h4&gt;&lt;p&gt;查看全部的控制组&lt;/p&gt;
</description>
        </item>
        <item>
        <title>K8S资源限制</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-limit/</link>
        <pubDate>Thu, 23 Jul 2020 11:20:41 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-limit/</guid>
        <description>&lt;p&gt;k8s集群中，可以对两种资源进行限制，一是内存，二是cpu，使用Linux cGroups进行限制&lt;/p&gt;
&lt;h3 id=&#34;cpu限制&#34;&gt;cpu限制
&lt;/h3&gt;&lt;p&gt;在Linux系统中，CPU的限制相比较内存的限制来说，更复杂一些。但是本身都可以通过cgroups来控制的，下面是一个K8S中的资源限制示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;resources&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;requests&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;50Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;50m&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;limits&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100m&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;单位后缀&lt;code&gt;m&lt;/code&gt;表示千分之一核，也就是说，在K8S中，一个cpu核心被量化为1000m。上面的示例requests需要50m，也就是百分之五的cpu，要申请一个cpu的全部核心，可以使用1000m，或者1来表示。&lt;/p&gt;
&lt;p&gt;这里调用docker来创建cgroups的时候，会有一些差异&lt;/p&gt;
&lt;p&gt;Linux系统和docker都是按照1024的时间片值来计算的，这里和K8S有24的差值。我们称之为shares&lt;/p&gt;
&lt;p&gt;shares用来设置CPU的相对值，如：a的shares值为1024，b的为512，则a的相对值为1024/1024+512 约为66%。shares有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a不忙，则b可以超过他的限制，a如果忙，则不能超过66的使用值&lt;/li&gt;
&lt;li&gt;当有一个新的c 1024shares加入时，这个值重新计算。1024/1024+1024+512=40%，所以说这个值随着cgroups数量而改变的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面资源限制有两个字段，一个是requests，一个是limits。requests值，对应的就是我们上文介绍的shares值来计算的。limits又是怎么计算的呢？&lt;/p&gt;
&lt;p&gt;其实他和requests使用的是不同的子系统来控制的。为什么会有单独的子系统呢。通过上文的介绍，你可能已经发现了，当一个进程没有设置shares的时候，他可以自由地使用cpu资源，而且shares子系统没法精准的控制使用的cpu，只能相对来控制。谷歌团队发现了这个问题，并且增加了一个子系统来控制：cpu带宽控制组。他定义了周期和配额两个属性。周期为1/10秒，100000微秒。配额为周期长度内可以使用的cpu时间数。两个配合起来可以精准的控制cpu的使用时长。周期值和配额均可以配置。&lt;/p&gt;
&lt;p&gt;下面是几个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 1.限制只能使用1个CPU（每250ms能使用250ms的CPU时间）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;250000&lt;/span&gt; &amp;gt; cpu.cfs_quota_us /* quota &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 250ms */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;250000&lt;/span&gt; &amp;gt; cpu.cfs_period_us /* period &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 250ms */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 2.限制使用2个CPU（内核）（每500ms能使用1000ms的CPU时间，即使用两个内核）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000&lt;/span&gt; &amp;gt; cpu.cfs_quota_us /* quota &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1000ms */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;500000&lt;/span&gt; &amp;gt; cpu.cfs_period_us /* period &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 500ms */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 3.限制使用1个CPU的20%（每50ms能使用10ms的CPU时间，即使用一个CPU核心的20%）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt; &amp;gt; cpu.cfs_quota_us /* quota &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 10ms */
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ echo &lt;span style=&#34;color:#ae81ff&#34;&gt;50000&lt;/span&gt; &amp;gt; cpu.cfs_period_us /* period &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 50ms */
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面例子中的100m,换算成这里就是10000/100000，默认的周期是100000，分别对应cfs_period_us=100000, cfs_quota_us=10000。&lt;/p&gt;
&lt;h3 id=&#34;内存限制&#34;&gt;内存限制
&lt;/h3&gt;&lt;p&gt;内存限制相对于cpu就没有那么的复杂了。他直接把你设置的值映射到cgroups的内存控制子系统上。内存限制如上文的示例，requests代表你要申请的最少内存，也就是说，节点必须有这些内存可以申请，我可以超过这个内存，也可以少于这些内存，但节点一定要有。limits代表，我使用的内存上限，一旦超过，容器就要被oom了，所以建议两个设置合理的值。&lt;/p&gt;
&lt;h3 id=&#34;默认限制&#34;&gt;默认限制
&lt;/h3&gt;&lt;p&gt;LimitRange 是用来设置 namespace 中 Pod 的默认的资源 request 和 limit 值，以及大小范围&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;LimitRange&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mem-limit-range&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;example&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;limits&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - &lt;span style=&#34;color:#f92672&#34;&gt;default&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# default limit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;512Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;defaultRequest&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# default request&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;256Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;max&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# max limit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;800Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;min&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# min request&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100Mi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0.3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;maxLimitRequestRatio&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# max value for limit / request&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;memory&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;cpu&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;type: Container # limit type, support&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Container / Pod / PersistentVolumeClaim&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;limitRange支持的参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default 代表默认的limit&lt;/li&gt;
&lt;li&gt;defaultRequest 代表默认的request&lt;/li&gt;
&lt;li&gt;max 代表limit的最大值&lt;/li&gt;
&lt;li&gt;min 代表request的最小值&lt;/li&gt;
&lt;li&gt;maxLimitRequestRatio 代表 limit / request的最大值。由于节点是根据pod request 调度资源，可以做到节点超卖，maxLimitRequestRatio 代表pod最大超卖比例。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Namespace</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/namespace/</link>
        <pubDate>Sun, 05 Jul 2020 22:30:20 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/namespace/</guid>
        <description>&lt;p&gt;Docker引爆了虚拟化领域对容器技术的关注，成为了现在最热门的技术之一。这边文章是对虚拟化技术的基础，名称空间进行总结。&lt;/p&gt;
&lt;h3 id=&#34;6大名称空间&#34;&gt;6大名称空间
&lt;/h3&gt;&lt;p&gt;在我的理解中，容器技术就像是一个正方体的盒子，有6个面组成，组成一个封闭的空间，这个6个面分别代表了内核系统调用的6个参数，也就是我们通常所说的6大名称空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机名和域名  UTS                             CLONE_NEWUTS&lt;/li&gt;
&lt;li&gt;信号量，共享内存，消息队列 IPC    CLONE_NEWIPC&lt;/li&gt;
&lt;li&gt;进程号 PID                                          CLONE_NEWPID&lt;/li&gt;
&lt;li&gt;网络 NET                                             CLONE_NEWNET&lt;/li&gt;
&lt;li&gt;挂载点 MOUNT                                  CLONE_NEWNS&lt;/li&gt;
&lt;li&gt;用户 USER                                           CLONE_NEWUSER&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上上面的6大名称空间实在内核3.8版本以后才开始成熟的。所以最好升级内核版本，这样才稳定。&lt;/p&gt;
&lt;h3 id=&#34;内核系统调用&#34;&gt;内核系统调用
&lt;/h3&gt;&lt;p&gt;创建一个新的进程，大家都熟悉是使用系统调用&lt;code&gt;clone（）&lt;/code&gt;，也是docker使用的方法。&lt;/p&gt;
&lt;p&gt;他的基本用法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;clone&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;child_func)(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;child_stack, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; flags, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;flags就是控制使用多少功能，上面6中就包含在其中&lt;/p&gt;
&lt;p&gt;child_func传入子进程的主函数&lt;/p&gt;
&lt;p&gt;child_stack 传入子进程的栈&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sents（）&lt;/code&gt;系统调用主要用于把进程加入一个已经存在的名称空间&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sents&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nstype)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;fd是要加入的名称空间描述符&lt;/p&gt;
&lt;p&gt;nstype可以检查名称空间是否符合自己的要求，0代表不检查&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unshare()&lt;/code&gt;系统调用是把原进程上进行隔离，不需要启动一个新的进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt;系统调用很多人比较熟悉，这里简单介绍下，fork本身去产生新进程会返回两次，一次是父进程，返回的是子进程的pid，子进程返回的是0，代表正确，负值代表错误。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例
&lt;/h3&gt;&lt;h5 id=&#34;uts使用&#34;&gt;uts使用
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;clone&lt;/span&gt; (child main, child_stack&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;STACK_SIZE, CLONE_NEWUTS&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; SIGCHID, NULL)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;ipc使用&#34;&gt;ipc使用
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;clone&lt;/span&gt; (child main, child_stack&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;STACK_SIZE, CLONE_NEWIPC&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; SIGCHID, NULL)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;pid使用&#34;&gt;pid使用
&lt;/h5&gt;&lt;p&gt;pid名称空间属于比较重要的隔离。内核首先创建了一个根名称空间，新的名称空间都是这个空间的子节点，构成一个树状结构，这样父节点可以看到子节点的进程，并且可以影响，反之不行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/namaspace.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;namespace&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在linux系统中，1号进程是上帝进程，一般负责管理和回收所有子进程，在名称空间中也一样，pid为1的进程对名称空间拥有特权，起特殊作用。kill命令无法影响父亲节点和兄弟节点。&lt;/p&gt;
&lt;p&gt;通常情况下，容器内最好运行一个进程，但是实在有多个进程的需求，1号进程就很重要，必须有管理的功能，如bash。init进程有忽略信号的权利，就是不接受信号，除非编写了逻辑。但是父亲节点的信号kill和stop信号不可忽略，父亲节点有权停止子节点。&lt;/p&gt;
&lt;h5 id=&#34;mount使用&#34;&gt;mount使用
&lt;/h5&gt;&lt;p&gt;历史上最早的名称空间，所以参数是CLONE_NEWNS，早起使用的是复制方法，就是把文件结构完整的复制一份给名称空间，但是存在一些问题：如无法自动挂载一些外部文件系统。&lt;/p&gt;
&lt;p&gt;2006年引入的挂载传播解决了这个问题，挂载传播定义了对象之间的关系，从属关系和共享关系。&lt;/p&gt;
&lt;p&gt;存在五种挂载状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享挂载，两个名称空间互相传播时间&lt;/li&gt;
&lt;li&gt;从属挂载，父亲空间影响儿子空间，反之不行&lt;/li&gt;
&lt;li&gt;共享/从属挂载，同时兼具两者的特征&lt;/li&gt;
&lt;li&gt;私有挂载，互不影响&lt;/li&gt;
&lt;li&gt;不可绑定挂载，互不影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认状态下，所有的挂载对象都是私有的。&lt;/p&gt;
&lt;p&gt;其他名称空间基本使用基本类似。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>浅谈容器网络</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-net1/</link>
        <pubDate>Thu, 02 Jul 2020 11:23:22 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-net1/</guid>
        <description>&lt;p&gt;容器领域的网络标准之争，持续时间很久了。一个是docker为代表的CNM，还有一个是kubernetes为代表的CNI，kubernetes已经是容器编排领域事实的标准了，CNI也是现在众多开发网络插件的遵循标准。&lt;/p&gt;
&lt;p&gt;在网络实现方面，现在分为两种主流的实现方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;叠加网络&lt;/li&gt;
&lt;li&gt;路由模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中代表的实现方案分别是Flannel和Calico，其中Flannel以VXLAN模式最为知名，是典型的二层叠加网络。Calico的三层路由方案是最为知名的，是典型的路由模式。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>K8S-Vloume</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-vloume/</link>
        <pubDate>Sat, 16 May 2020 11:20:29 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/k8s-vloume/</guid>
        <description>&lt;h1 id=&#34;基本介绍&#34;&gt;基本介绍
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;场景一：当我们用K8S创建了一个pod的时候，容器顶部附加了一个可写层用于程序运行时的数据读写，但在容器结束运行的时候，这个可写层也会随之消失，数据也会消失不见，数据无持久化。&lt;/li&gt;
&lt;li&gt;场景二：每个pod都有自己的文件系统，当本次pod结束后，后创建的pod不能有效识别到前一个pod遗留的数据，数据不共享问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;K8S通过定义存储卷来解决上述的问题。存储卷本身不是顶级资源，像pod， service那样，而是被定义为pod的一个组成部分，因为不是独立的K8S对象，不能独立的创建和删除，而且pod的所有容器均可共享使用这个卷。&lt;/p&gt;
&lt;p&gt;下面一个简单的应用实例，第一个容器有htdocs目录和logs目录，存放html和日志文件，第二个容器运行了一个代理来创建html，第三个容器来收集日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/k8s/vloume-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;volume-1&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;增加共享卷以后&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/k8s/volume-2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;volume-2&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;webserver写入日志，日志收集器来收集日志，两个容器内的文件系统的logs文件夹应该挂载同一个卷，htdocs和html文件夹，一个生成文件，一个读取文件，也应该使用同一个共享卷。&lt;/p&gt;
&lt;h3 id=&#34;卷类型&#34;&gt;卷类型
&lt;/h3&gt;&lt;p&gt;K8S中有多种卷的类型，下面的列表可以参考：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;emptDir&lt;/th&gt;
&lt;th&gt;存储临时数据的简单空目录&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;hostPath～&lt;/td&gt;
&lt;td&gt;用于将目录从work&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emptDir～&lt;/td&gt;
&lt;td&gt;存储临时数据的简单空目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gitRepo&lt;/td&gt;
&lt;td&gt;检出Git仓库内容来初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nfs&lt;/td&gt;
&lt;td&gt;挂载pod中的NFS共享卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;谷歌高效存储卷 亚马逊弹性块存储 微软磁盘卷～&lt;/td&gt;
&lt;td&gt;公有云存储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cinder cephfs glusterfs～&lt;/td&gt;
&lt;td&gt;其他网络类型的存储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;configmap secret～&lt;/td&gt;
&lt;td&gt;K8S部分资源和集群信息公开给pod的特殊卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PVC～&lt;/td&gt;
&lt;td&gt;预置或者动态配置的持久存储类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面有波浪线的是使用类型比较多的卷，一个容器可以挂在多个不通类型的卷到不通的目录上。&lt;/p&gt;
&lt;h3 id=&#34;使用示例&#34;&gt;使用示例
&lt;/h3&gt;&lt;p&gt;emptDir&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kind: Pod
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;metadata::
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: fortune
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  containers;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - images; luksa/fortune
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name: html-gen
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    volumeMounts:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    - name: html &lt;span style=&#34;color:#75715e&#34;&gt;# 挂载的卷的名称&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      mountPath: /var/htdocs &lt;span style=&#34;color:#75715e&#34;&gt;# 这里指明容器内的挂在位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      .......
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   volumes:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   - name: html   &lt;span style=&#34;color:#75715e&#34;&gt;# 这里定义了一个卷&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     emptyDir: &lt;span style=&#34;color:#f92672&#34;&gt;{}&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;hostPath&lt;/p&gt;
&lt;p&gt;这种类型属于比较常用的，我们生产线上都是挂载hostpath进去，写日志，ds filebeat去收集本机的日志到某一个日志机上&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; volumeMounts:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; - mountPath: /home/logs &lt;span style=&#34;color:#75715e&#34;&gt;# 挂载位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   name: hostpath &lt;span style=&#34;color:#75715e&#34;&gt;# 卷名称&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      volumes:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        - name: hostpath &lt;span style=&#34;color:#75715e&#34;&gt;#卷名称&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          hostPath:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            path: /www-volume/logs &lt;span style=&#34;color:#75715e&#34;&gt;# 主机路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;pvpvc&#34;&gt;PV&amp;amp;&amp;amp;PVC
&lt;/h2&gt;&lt;p&gt;之前的两种类型都需要pod的开发人员了解集群中的真实网络存储的基础设施，这对专业开发人员并不友好，理想的状况是，开发人员不需要知道这些底层设施，当我需要时，申请就可以了。 这就是pv和pvc的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/2020-05-23-PVandPVC.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pv&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 定义持久卷&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kind: persistentVolume
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: mongodb-pv
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  capacity:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    storage: 1Gi  &lt;span style=&#34;color:#75715e&#34;&gt;# 大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  accessModes: &lt;span style=&#34;color:#75715e&#34;&gt;# 可以被单个客户端挂载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - ReadWriteOnce
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  - ReadOnlyMany
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  persistentVolumeReclimPolicy: Retain &lt;span style=&#34;color:#75715e&#34;&gt;# 声明被释放后，pv将会保留&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  gcePersistentDisk:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pdName: mongodb
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fstype: ext4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;持久卷不属于任何名称空间，是集群层面的资源，持久卷声明是属于某一个名称空间的资源，不能跨名称空间调用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# pvc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kind: pVC &lt;span style=&#34;color:#75715e&#34;&gt;#这里应该写全称&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;metadata: 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: monfodb-pvc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  resource:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    requests:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      storage: 1Gi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    accessModes:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    - ReadWriteOnce
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    storageClassName: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;volumes:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- name: mongodb-data
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  persistentVolumeClaim:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    claimName: monfodb-pvc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除持久卷：remian模式下需要手动释放&lt;/p&gt;
&lt;p&gt;回收策略配置： recycle 和 delete将会自动释放持久卷&lt;/p&gt;
&lt;h2 id=&#34;storageclass&#34;&gt;storageclass
&lt;/h2&gt;&lt;p&gt;使用pv和pvc可以屏蔽底层的基础设施，但是仍但需要一个集群管理员来创建pv，为了解决这个问题，可以通过动态配置持久卷来自动自行次任务。&lt;/p&gt;
&lt;p&gt;创建storageclass需要一个中间程序来连接我们的存储，无论是网络存储，云存储还是其他的存储。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apiVersions: storage.k8s.io/v1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kind: StorageClass
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: fast
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;procisioner: kubenet. &lt;span style=&#34;color:#75715e&#34;&gt;#这里是插件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parameters:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  type: pd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 传给插件的参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 。。。
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; pvc声明
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; spec:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; storageClass:fast
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Kubernetes基础架构(3)</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-base-3/</link>
        <pubDate>Sun, 12 Apr 2020 15:04:12 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-base-3/</guid>
        <description>&lt;h1 id=&#34;前言&#34;&gt;前言
&lt;/h1&gt;&lt;p&gt;学习了一些基本的概念，我们开始一层层拆解K8S。学习任何一个主流的技术之前，一般都是从他的架构开始学习，这样可以比较全面的把握它的工作流程。&lt;/p&gt;
&lt;p&gt;本片文章介绍如下内容：&lt;/p&gt;
&lt;p&gt;1-什么是集群控制平面和节点&lt;/p&gt;
&lt;p&gt;2-etcd的基础介绍&lt;/p&gt;
&lt;p&gt;3-附件和插件机制&lt;/p&gt;
&lt;h1 id=&#34;集群控制平面&#34;&gt;集群控制平面
&lt;/h1&gt;&lt;p&gt;集群控制平面，又叫做AKA master，也就是我们通常所说的master节点，通常是用于控制整个集群的运行状态。他可以单节点运行，也可以高可用运行，也可以托管于自身的集群上运行。支持REST API去CRUD集群资源。控制平面提供了集群唯一的入口，集群内的全部资源的操作，都要通过master节点来进行，提供了安全性的保证，可提供了便捷的操作。master节点主要包含如下的组件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;主要功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;API server&lt;/td&gt;
&lt;td&gt;k8s api服务，主要提供REST操作，验证资源和更新资源和etcd交互&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Contorller Manager&lt;/td&gt;
&lt;td&gt;其他集群功能的控制使用一个单独的进程来管理，就是控制管理器，控制某种资源的预期状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scheculer&lt;/td&gt;
&lt;td&gt;监控未调度的pod去绑定他们到主机，通过/binding的pod子api&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;etcd&#34;&gt;etcd
&lt;/h3&gt;&lt;p&gt;集群状态存储，api server所有的更新数据都要存储在etcd内部，同时etcd提供了watch的支持，就是当数据发生变化的时候回返回当前的数据，未发生变化时，阻塞watch的进程。&lt;/p&gt;
&lt;p&gt;以上的组建主要是master节点所要依赖的组建，其中存储组建可以单独作为一个种类介绍&lt;/p&gt;
&lt;h1 id=&#34;节点&#34;&gt;节点
&lt;/h1&gt;&lt;p&gt;这里的节点就是前文中的node，主要是k8s中的工作节点，主要负责运行pod。主要包含如下的组建：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;主要功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kubelet&lt;/td&gt;
&lt;td&gt;主要负责运行调度到该节点上的pod，并且负责上报当前节点上的全部pod的运行状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;containner runtime&lt;/td&gt;
&lt;td&gt;容器运行时，主要是把容器跑起来，拉取镜像。kubelet和容器运行时通过容器运行时接口来交互，接口目前支持：rkt，docker，cri-o，frakti&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;kubeproxy创建规则于iptables上，用于提供负载均衡和高可用解决方案，将流量转发到后端的pod上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;add-ons--plugins&#34;&gt;add-ons &amp;amp; plugins
&lt;/h1&gt;&lt;p&gt;附件，主要为集群提供扩展功能，目前主流的附件包含如下几个：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DNS&lt;/td&gt;
&lt;td&gt;提供解析功能和服务发现功能，用于集群内部的pod之间的通讯解析和查找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;network&lt;/td&gt;
&lt;td&gt;主要是集群之间的node进行通讯提供功能，主要是为每个节点分配一个网段的地址，每个pod调度后就可以获取到一个IP地址，通过ip地址进行通讯&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结
&lt;/h1&gt;&lt;p&gt;本片文章主要把一些基本的概念进行了一些简单的讲述，接下来的几篇文章会对几个流程进行讲解，主要包含如下几个：&lt;/p&gt;
&lt;p&gt;1-master节点和node节点之间的通讯&lt;/p&gt;
&lt;p&gt;2-调度器的工作机制&lt;/p&gt;
&lt;p&gt;3-控制器的工作机制&lt;/p&gt;
&lt;p&gt;4-kubelet运行机制&lt;/p&gt;
&lt;p&gt;5-一个pod的完整运行流程总结&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Kubernetes基本概念(2)</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-base-2/</link>
        <pubDate>Sat, 28 Mar 2020 23:21:09 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-base-2/</guid>
        <description>&lt;h2 id=&#34;replicationcontroller&#34;&gt;ReplicationController
&lt;/h2&gt;&lt;p&gt;一种k8s的资源类型，可以确保pod始终处于运行状态，如果减少则重新创建，增加则删除pod&lt;/p&gt;
&lt;p&gt;RC主要有三个部分&lt;/p&gt;
&lt;p&gt;label Selector： 标签选择器&lt;/p&gt;
&lt;p&gt;Replica count：副本个数&lt;/p&gt;
&lt;p&gt;pod template： pod 模板&lt;/p&gt;
&lt;p&gt;这里需要注意的是标签选择器所选择的标签和pod模板内的标签必须是一致的，这样pod才会受RC控制。&lt;/p&gt;
&lt;h2 id=&#34;replicaset&#34;&gt;ReplicaSet
&lt;/h2&gt;&lt;p&gt;RC资源的进阶版，主要增强了RC的标签选择器功能，RC的标签选择器只支持等式选择，如：env=dev或者app=nginx。RS增强了这部分功能，支持env in dev or pro 这种写法，就是表达式写法，可以让我们有更灵活的使用。&lt;/p&gt;
&lt;h2 id=&#34;deployment&#34;&gt;Deployment
&lt;/h2&gt;&lt;p&gt;一种资源类型，在生产环境中，通常使用更高级的资源来创建pod，不直接使用RC和RS，通常也不直接创建pod，而是使用副本控制器来创建pod，因为他能使pod维持在我们期望的一个状态，一旦有pod死掉，也会重新复制出来新的副本来维持我们所需要的状态。但是如果不使用副本控制器来创建，当前pod死掉，就真的死掉了，会直接影响业务。deployment是RS的高级封装，使用更友好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl run nginx --image=cargo.caicloud.io/caicloud/nginx:1.9.7 --replicas=1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl run --generator&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;run-pod/v1 or kubectl create instead.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;deployment.apps/nginx created
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;上边提示的是建议使用，可以看到一个deployment被创建了
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如何获取我们刚才创建的deployment&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;[root@kong-ali-bj-001 ~]# kubectl get deployment
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   1/1     1            1           22s
可以获得刚才创建好的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;label&#34;&gt;Label
&lt;/h2&gt;&lt;p&gt;标签在kubernetes是非常重要的概念，基本上各类控制器都要依赖标签来选择对应的资源，例如：deployment根据pod的标签来选择相对应的pod，污点也是根据标签来选择容忍的。&lt;/p&gt;
&lt;p&gt;查看node的标签&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get node --show-labels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME               STATUS   ROLES    AGE   VERSION   LABELS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kong-ali-bj-001    Ready    master   28d   v1.17.3   beta.kubernetes.io/arch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;amd64,beta.kubernetes.io/os&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;linux,kubernetes.io/arch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;amd64,kubernetes.io/hostname&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;kong-ali-bj-001,kubernetes.io/os&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;linux,node-role.kubernetes.io/master&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pgsql-ali-bj-001   Ready    &amp;lt;none&amp;gt;   28d   v1.17.3   beta.kubernetes.io/arch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;amd64,beta.kubernetes.io/os&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;linux,kubernetes.io/arch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;amd64,kubernetes.io/hostname&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pgsql-ali-bj-001,kubernetes.io/os&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;linux
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可以看到 beta.kubernetes.io/arch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;amd64 这种类型的就是标签
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看pod的标签&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get pod --show-labels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     READY   STATUS    RESTARTS   AGE     LABELS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myrepo-nwwn7             1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          28d     run&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;myrepo,test_label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pro
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myrepo-qdhng             1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          28d     run&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;myrepo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nginx-6645f84fcd-q9294   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          8m55s   pod-template-hash&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;6645f84fcd,run&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;nginx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对pod添加标签&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl label pod myrepo-nwwn7 tt=aa&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pod/myrepo-nwwn7 labeled
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;label添加成功
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; kubectl get pod --show-labels       
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     READY   STATUS    RESTARTS   AGE   LABELS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myrepo-nwwn7             1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          28d   run&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;myrepo,test_label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pro,tt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;aa
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可以看到添加上去的lable
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;configmap&#34;&gt;configmap
&lt;/h2&gt;&lt;p&gt;k8s用来管理配置资源信息的一种资源类型。通过单独创建configmap，再将configmap挂载到pod内部，分离配置和应用。创建configmap可以从yaml文件和文件中创建，普通文件的格式类似如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clor.good=true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;map.ip=10.10.10.10
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到也是key-vlaue类型的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl create configmap test --from-file=test.pro &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;configmap/test created
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;从文件创建configmap
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get configmap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME   DATA   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;test   &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;      40s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;获取configmap
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@kong-ali-bj-001 ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl describe configmap test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Name:         test
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Labels:       &amp;lt;none&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Annotations:  &amp;lt;none&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Data
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;====&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;test.pro:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;----
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;color.good&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;allow&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Events:  &amp;lt;none&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;查看configmap的详细信息
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Docker镜像操作</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
        <pubDate>Thu, 05 Mar 2020 23:03:27 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
        <description>&lt;p&gt;容器启动之前，镜像必须先存在本地，如果本地不存在镜像，回去仓库获取镜像，并且pull的本地&lt;/p&gt;
&lt;h2 id=&#34;获取镜像&#34;&gt;获取镜像
&lt;/h2&gt;&lt;p&gt;  获取镜像的命令是&lt;code&gt;docker pull&lt;/code&gt;命令，命令格式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;docker pull [选项] [docker registry 地址/仓库名:标签]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的参数选项可以通过&lt;code&gt;docker pull --help&lt;/code&gt;查看到。一般情况下获取镜像的命令是&lt;code&gt;docker pull 用户名/仓库名：tag&lt;/code&gt;，如果没写用户名，则代表是官方的镜像库，如：&lt;code&gt;docker pull centos:7.4&lt;/code&gt;,就是获取centos的7.4版本的镜像。上面的命令没有给出地址，所以默认从&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;docker hub&lt;/a&gt;获取。如果不写版本，则拉取标签为latest的镜像。&lt;/p&gt;
&lt;h2 id=&#34;运行容器&#34;&gt;运行容器
&lt;/h2&gt;&lt;p&gt;  本地存在镜像以后，我们便可以尝试去运行镜像了，运行容器使用&lt;code&gt;docker run&lt;/code&gt;命令，格式如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;$ docker run -it --rm \
    ubuntu:18.04 \
    bash
    -it 以交互式方式运行
    --rm 退出停止删除
    bash 容器启动后运行的命令
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到一个和正常的系统一样的终端，就是我们运行起来的容器了。&lt;/p&gt;
&lt;h2 id=&#34;列出镜像&#34;&gt;列出镜像
&lt;/h2&gt;&lt;p&gt;  一台安装有docker的机器上，使用&lt;code&gt;docker image ls&lt;/code&gt;命令可查看全部已存在镜像，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;$ docker image ls
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
nginx                latest              05a60462f8ba        5 days ago          181 MB
mongo                3.2                 fe9198c04d62        5 days ago          342 MB
&amp;lt;none&amp;gt;               &amp;lt;none&amp;gt;              00285df0df87        5 days ago          342 MB
ubuntu               18.04               f753707788c5        4 weeks ago         127 MB
ubuntu               latest              f753707788c5        4 weeks ago         127 MB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;包含仓库名 标签 镜像id 创建时间 大小，请注意这里看到的镜像体积不一定是是实际的大小，因为镜像本身和分层构建的，可能这个镜像的前面几层适合别人复用的层。另外这里的镜像大小要比docker hub上大，这是因为docker hub上包含的镜像大小是压缩后的大小。
  &lt;code&gt;docker image ls ubuntu&lt;/code&gt;可以列出所有仓库名称为ubuntu的镜像，上述的镜像列表中可以看到一个《none》的镜像，这种镜像叫做虚悬镜像，产生这种镜像的原因一般是有新的镜像和这个镜像重复名称和tag导致原本的镜像名称和tag被占用，从而名称变成none，下面的命令可以专门的查看这类镜像&lt;code&gt;docker image ls -f dangling=true&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;$ docker image ls -f dangling=true
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              00285df0df87        5 days ago          342 MB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般来说这类镜像已经失去了价值，除了占空间已经无用，可以删除掉，使用&lt;code&gt;docker image prune&lt;/code&gt;删除。&lt;/p&gt;
&lt;h2 id=&#34;删除镜像&#34;&gt;删除镜像
&lt;/h2&gt;&lt;p&gt;删除镜像使用&lt;code&gt;docker image rm&lt;/code&gt;命令，一般删除的时候使用镜像ID来删除，docker image ls列出的IMAGE ID是这个镜像的短ID，&lt;code&gt;docker image ls --digests&lt;/code&gt;列出的是镜像的长ID，删除镜像会产生两种类型的信息 untagged和deleted一种是标记取消，一种是镜像层删除，当镜像层不被其他的镜像标记或者依赖的时候，就会在执行删除操作的时候被删除，下面是一些演示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-linux&#34; data-lang=&#34;linux&#34;&gt;$ docker image ls
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB
redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB
docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB
nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB
镜像列表


$ docker image ls --digests
REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE
node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB

$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
长格式删除

$ docker image rm 501ad78535f0
Untagged: redis:alpine
Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d
Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7
Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b
Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23
Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa
Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3
Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7
短格式删除

$ docker image rm centos
Untagged: centos:latest
Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a
Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38
仓库名和标签删除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;镜像的基本操作就介绍到这里了，更详细的用法，请参考官方文档。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Docker三部曲</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker-%E4%B8%89%E9%83%A8%E6%9B%B2/</link>
        <pubDate>Wed, 04 Mar 2020 23:03:27 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/docker-%E4%B8%89%E9%83%A8%E6%9B%B2/</guid>
        <description>&lt;h2 id=&#34;概述&#34;&gt;概述
&lt;/h2&gt;&lt;p&gt;  对于整个docker容器技术的体系来说，主要划分为三部分：镜像，容器和仓库&lt;/p&gt;
&lt;h2 id=&#34;什么是镜像&#34;&gt;什么是镜像
&lt;/h2&gt;&lt;p&gt;  在操作系统的体系，整个空间被横向切割为两大空间，内核空间和用户空间，在Linux系统启动的时候，内核启动后，会挂载一个root文件系统为用户空间提供支持，而镜像其实就是一个root文件系统，但是是一种特殊的root文件系统，提供包含了容器运行时所需要的程序，文件，资源，库，配置，还包含一些环境变量，用户等，镜像包含的全是静态的文件，在构建完成后，将不会改变。&lt;/p&gt;
&lt;p&gt;  如何形象的理解镜像？其实我们可以想象一下，镜像其实就是一个高层楼房，是有一层层叠加构成的。最初，什么也没有的时候就是空白镜像。后来我在空地上建了一层房子，并且分割好一个个房间，把东西分门别类的放进去，这就构成了我们的镜像，这里镜像可能是流行的发型版，如：红帽，乌班图等。后来，我发现我需要一个新的功能，但是一层已经建好，而且摆放好了，我只能再建一层，把我要的东西存储进去。所以整体看起来，镜像是分层的。这里就会存在一个问题，二层可能有三个住户，他们都想去一层修改东西，这就会导致大家读到的东西是不一致的，为了解决这个问题，一层就规定，我这一层是只能读的，不能写，你们要写，请复制一份到你们那里，自己修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/docker/docker-image.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;镜像使用的技术&#34;&gt;镜像使用的技术
&lt;/h4&gt;&lt;p&gt;  Union FS 联合文件系统是镜像技术使用的文件系统技术，为什么使用这个技术？镜像包含一个root文件系统，一般来说可能会比较大，所以使用分层存储的架构，ISO类型的镜像和这个是不一样的，这里的docker镜像其实是一个虚拟的概念，其最终的体现往往是一组文件系统的组合，而ISO一般是一个打包好的文件。
  镜像build时一般是一层层生成，前一层是后一层的基础，本层build完就会固定，不会发生改变了，执行删除操作一般是标记为不可见，文件会一直存在，因此构建是尽量减少冗余文件的生成。&lt;/p&gt;
&lt;h2 id=&#34;什么是容器&#34;&gt;什么是容器
&lt;/h2&gt;&lt;p&gt;  镜像和容器的关系，就像程序和进程的关系，容器就是运行时的镜像，容器可以被启动，停止，删除，暂停等，镜像一般只能被创建和删除。容器运行时会被添加一层可写层在最上边，用于容器运行时的数据增删改查，停止后会消失，不被保存，如何保存，会在后续的文章中说明。
  容器运行的本质是进程,但和普通的进程是不一样的，他被添加了障眼法，运行在一个与世隔绝的空间内，也就是自己的名称空间内，就好像是一个独立的用户空间一样。空间内有自己的网络配置，用户，进程等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cdn.oyfacc.cn/docker/continer.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;cont&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是仓库&#34;&gt;什么是仓库
&lt;/h2&gt;&lt;p&gt;  仓库，顾名思义就是存储镜像的地方，因为我们的镜像不是运行在一个主机上，在多个主机之间进行镜像的传输，就需要有一个存储和分发镜像的地方，就是仓库。一个仓库通常被永爱存储同一个镜像的不同版本，仓库被residtry统一管理。仓库名通常xx/xx:tag这种格式，用户名/服务名:tag,一般在私有仓库中往往是 地址or域名:端口/服务名:tag,这种格式，公有的docker registry是docker hub，私有的包含harbor或者nexus，或者官方的regisitry api。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker Hub 官方仓库地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker结构分解&#34;&gt;docker结构分解
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://containerd.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;containerd&lt;/a&gt; is a container runtime which can manage a complete container lifecycle - from image transfer/storage to container execution, supervision and networking.&lt;/li&gt;
&lt;li&gt;container-shim handle headless containers, meaning once runc initializes the containers, it exits handing the containers over to the container-shim which acts as some middleman.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://runc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;runc&lt;/a&gt; is lightweight universal run time container, which abides by the OCI specification. runc is used by containerd for spawning and running containers according to OCI spec. It is also the repackaging of libcontainer.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.grpc.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grpc&lt;/a&gt; used for communication between containerd and docker-engine.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.opencontainers.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OCI&lt;/a&gt; maintains the OCI specification for runtime and images. The current docker versions support OCI image and runtime specs.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Kubernetes基本概念(1)</title>
        <link>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
        <pubDate>Tue, 03 Mar 2020 23:03:27 +0800</pubDate>
        
        <guid>http://localhost:1313/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF/kubernetes-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
        <description>&lt;h2 id=&#34;node&#34;&gt;node
&lt;/h2&gt;&lt;p&gt;  &lt;code&gt;node&lt;/code&gt;即节点，是物理服务器或者虚拟服务器，他们是组成kubernetes资源池的基础。节点分为两种色，&lt;code&gt;master&lt;/code&gt;节点和&lt;code&gt;worker&lt;/code&gt;节点。master节点负责资源调度，集群状态控制等，worker节点负责运行用户容器，承接负载。&lt;/p&gt;
&lt;h5 id=&#34;获取node信息&#34;&gt;获取node信息
&lt;/h5&gt;&lt;p&gt;  通过&lt;code&gt;kubectl&lt;/code&gt;命令可以获取node信息&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ kubectl get nodes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     STATUS                     AGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i-2ze0tfg75y5plzvnd29h   Ready,SchedulingDisabled   2d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i-2ze0woc5l1230xs5zxry   Ready                      2d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i-2ze14a3m7riw0l18oemg   Ready                      2d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i-2ze14a3m7riw0l18oemh   Ready                      2d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i-2ze1nwnt9tc3wg83rsru   Ready                      2d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  获取更详细的信息可以使用如下命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get nodes -o wide&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                                 STATUS    ROLES     AGE       VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION              CONTAINER-RUNTIME
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cn-shanghai.i-uf6143y5dc78k   Ready     master    1y        v1.11.5   172.18.88.44   &amp;lt;none&amp;gt;        CentOS Linux &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Core&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;   3.10.0-693.2.2.el7.x86_64   docker://17.6.2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cn-shanghai.i-uf61jtxho26   Ready     &amp;lt;none&amp;gt;    247d      v1.11.5   172.18.89.45   &amp;lt;none&amp;gt;        CentOS Linux &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Core&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;   3.10.0-693.2.2.el7.x86_64   docker://17.6.2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  更详细的信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl describe nodes  cn-shanghai.i-uf6143y5dc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;···信息太长这里就不展示了&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;pod&#34;&gt;pod
&lt;/h1&gt;&lt;p&gt;  &lt;code&gt;pod&lt;/code&gt;是kubernetes非常重要的概念，他是运行应用的载体。有人说，pod是容器吗？等同吗？pod不是容器，pod更像是容器的封装体，如果把容器比喻为一个个的木箱子，那么pod就像是一个集装箱，一个集装箱可以装一个或多个木箱子，并且有挂钩这些方便吊装的装置。所以说pod是容器的封装，解决的是容器编排问题。&lt;/p&gt;
&lt;p&gt;  获取pod，不指定名称空间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl get pods &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  获取pod，指定名称空间，名称空间就是www&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl get pods -n www&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nginx-646b46d648-hbwg2   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          101s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  获取pod运行于哪个节点&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl get pods -n www -o wide&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE       NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nginx-646b46d648-hbwg2   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          2m23s   172.17.0.11   minikube   &amp;lt;none&amp;gt;   
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  获取pod中的日志&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl logs 646b46d648-hbwg2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  交互方式进入pod的内部&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl exec -it nginx-646b46d648-hbwg2 /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  对pod执行一个命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# kubectl exec nginx-t213217u -- ls -l&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  这里的双横线（&amp;ndash;）区分的是本地终端命令和容器中执行的命令，当中执行的命令只有一个单词时，可以忽略。&lt;/p&gt;
&lt;h2 id=&#34;namespace&#34;&gt;Namespace
&lt;/h2&gt;&lt;p&gt;  namespace， 名称空间，是一个虚拟的空间，主要是用来构建一个虚拟的资源成，将资源池划分成多个虚拟的区域，互不干扰。不通资源池的资源可以重名，但是名称空间本身不可以重名，相同的名称空间内的资源也不可以重名。&lt;/p&gt;
&lt;p&gt;  获取名称空间&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# kubectl get ns &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME              STATUS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;default           Active   27h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube-node-lease   Active   27h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube-public       Active   27h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube-system       Active   27h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tutorial          Active   7s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
